<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Select Area from OpenStreetMap</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            position: absolute;
            top: 100px;
            bottom: 0;
            left: 0;
            right: 0;
        }

        #toolbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background-color: #28722e;
            color: white;
            padding: 10px 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .toolbar-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .toolbar-row:last-child {
            margin-bottom: 0;
        }

        #toolbar h3 {
            margin: 0;
            font-size: 18px;
        }

        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: #27ae60;
        }

        .btn-success:hover {
            background-color: #229954;
        }

        .btn-draw {
            background-color: #3498db;
        }

        .btn-draw:hover {
            background-color: #2980b9;
        }

        .btn-draw.drawing {
            background-color: #c0392b;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(192, 57, 43, 0.5); }
            70% { box-shadow: 0 0 0 8px rgba(192, 57, 43, 0); }
            100% { box-shadow: 0 0 0 0 rgba(192, 57, 43, 0); }
        }

        #info {
            color: #ecf0f1;
            font-size: 12px;
            margin-left: 20px;
        }

        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            font-size: 12px;
            max-width: 300px;
        }

        .status-info {
            color: #2c3e50;
        }

        .status-warning {
            color: #e67e22;
            font-weight: bold;
        }

        .status-error {
            color: #e74c3c;
            font-weight: bold;
        }

        #warningModal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            color: #e74c3c;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .modal-header::before {
            content: '⚠';
            font-size: 30px;
            margin-right: 10px;
        }

        .modal-body {
            color: #2c3e50;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .btn-modal {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .btn-modal:hover {
            background-color: #2980b9;
        }

        .btn-modal-primary {
            background-color: #27ae60;
        }

        .btn-modal-primary:hover {
            background-color: #229954;
        }

        #searchContainer {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            max-width: 600px;
        }

        #searchInput {
            flex: 1;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            outline: none;
        }

        #searchInput:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        #searchBtn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }

        #searchBtn:hover {
            background-color: #2980b9;
        }

        #searchBtn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        #searchResults {
            position: absolute;
            top: 100px;
            left: 20px;
            right: 20px;
            max-width: 600px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
        }

        .search-result-item {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background-color: #f5f5f5;
        }

        .search-result-name {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 3px;
        }

        .search-result-address {
            font-size: 12px;
            color: #7f8c8d;
        }

        .search-no-results {
            padding: 15px;
            text-align: center;
            color: #7f8c8d;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <div class="toolbar-row">
            <h3>Select area from OpenStreetMap</h3>
            <div>
                <button id="drawBtn" class="btn btn-draw btn-draw-rect" onclick="startDrawing('rectangle')">&#9645; Draw Rectangle</button>
                <button id="drawPolyBtn" class="btn btn-draw btn-draw-poly" onclick="startDrawing('polygon')">&#11040; Draw Polygon</button>
                <button id="clearBtn" class="btn" onclick="clearSelection()">Clear Selection</button>
                <button id="loadBtn" class="btn btn-success" onclick="loadToDesignBuilder()" disabled>Load to
                    DesignBuilder</button>
            </div>
        </div>
        <div class="toolbar-row">
            <div id="searchContainer">
                <input type="text" id="searchInput" placeholder="Search for a location (e.g., London, Paris, New York)"
                    onkeypress="handleSearchKeyPress(event)" />
                <button id="searchBtn" onclick="searchLocation()">Search</button>
            </div>
            <span id="info">Draw a rectangle or polygon on the map to select an area</span>
        </div>
    </div>

    <div id="searchResults"></div>

    <div id="map"></div>

    <div id="status" class="status-info">
        Ready. Draw a rectangle to select an area.
    </div>

    <!-- Warning Modal -->
    <div id="warningModal">
        <div class="modal-content">
            <div class="modal-header">
                Area Too Large
            </div>
            <div class="modal-body">
                <p>The selected area (<strong><span id="modalAreaText"></span></strong>) exceeds the maximum size of
                    <strong>5 km²</strong>.
                </p>
                <p>OpenStreetMap does not support downloading areas larger than <strong>5 km²</strong>.</p>
                <p>Please select a smaller area.</p>
            </div>
            <div class="modal-buttons">
                <button class="btn-modal btn-modal-primary" onclick="closeWarningModal()">OK</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Draw JS -->
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

    <script>
        var map;
        var drawnItems;
        var drawControl;
        var drawHandler = null;
        var isDrawing = false;
        var activeDrawMode = null; // 'rectangle' or 'polygon'
        var currentBounds = null;
        var currentPolygonVertices = null; // Array of {lat, lng} for polygon selections
        var currentArea = 0;
        var MAX_AREA_KM2 = 5; // Maximum area in square kilometers
        var searchMarker = null; // Marker for search results

        // Initialize map
        function initMap() {
            // Create map centered on London
            map = L.map('map').setView([51.505, -0.09], 13);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            // Initialize drawn items layer
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Initialize draw control
            drawControl = new L.Control.Draw({
                position: 'topright',
                draw: {
                    polyline: false,
                    polygon: false,
                    circle: false,
                    circlemarker: false,
                    marker: false,
                    rectangle: {
                        shapeOptions: {
                            color: '#3498db',
                            weight: 2,
                            fillOpacity: 0.2
                        }
                    }
                },
                edit: {
                    featureGroup: drawnItems,
                    remove: false
                }
            });
            map.addControl(drawControl);

            // Handle drawing
            map.on(L.Draw.Event.CREATED, function (event) {
                var layer = event.layer;
                setDrawingState(false);

                // Clear previous selection
                drawnItems.clearLayers();

                // Add new selection
                drawnItems.addLayer(layer);

                // Get bounds (works for both rectangle and polygon)
                currentBounds = layer.getBounds();

                // Check if this is a polygon (has getLatLngs with nested array)
                if (layer.getLatLngs && !(layer instanceof L.Rectangle)) {
                    // Polygon — store vertices
                    var latlngs = layer.getLatLngs()[0]; // First ring
                    currentPolygonVertices = latlngs.map(function (ll) {
                        return { lat: ll.lat, lng: ll.lng };
                    });
                    // Calculate polygon area using Shoelace formula in km²
                    currentArea = calculatePolygonAreaKm2(currentPolygonVertices);
                } else {
                    // Rectangle — no polygon filter needed
                    currentPolygonVertices = null;
                    var ne = currentBounds.getNorthEast();
                    var sw = currentBounds.getSouthWest();
                    var latDiff = ne.lat - sw.lat;
                    var lonDiff = ne.lng - sw.lng;
                    var latKm = latDiff * 111.32;
                    var lonKm = lonDiff * 111.32 * Math.cos((ne.lat + sw.lat) / 2 * Math.PI / 180);
                    currentArea = Math.abs(latKm * lonKm);
                }

                // Update UI
                updateStatus();
            });

            map.on(L.Draw.Event.EDITED, function (event) {
                var layers = event.layers;
                layers.eachLayer(function (layer) {
                    currentBounds = layer.getBounds();

                    if (layer.getLatLngs && !(layer instanceof L.Rectangle)) {
                        var latlngs = layer.getLatLngs()[0];
                        currentPolygonVertices = latlngs.map(function (ll) {
                            return { lat: ll.lat, lng: ll.lng };
                        });
                        currentArea = calculatePolygonAreaKm2(currentPolygonVertices);
                    } else {
                        currentPolygonVertices = null;
                        var ne = currentBounds.getNorthEast();
                        var sw = currentBounds.getSouthWest();
                        var latDiff = ne.lat - sw.lat;
                        var lonDiff = ne.lng - sw.lng;
                        var latKm = latDiff * 111.32;
                        var lonKm = lonDiff * 111.32 * Math.cos((ne.lat + sw.lat) / 2 * Math.PI / 180);
                        currentArea = Math.abs(latKm * lonKm);
                    }

                    updateStatus();
                });
            });

            // Reset draw button when drawing is cancelled (e.g. Escape key)
            map.on('draw:drawstop', function () {
                setDrawingState(false);
            });

            updateStatus();
        }

        function startDrawing(mode) {
            if (isDrawing) {
                // Cancel current drawing
                if (drawHandler) {
                    drawHandler.disable();
                }
                setDrawingState(false);
                return;
            }

            activeDrawMode = mode;
            var shapeOptions = {
                color: '#3498db',
                weight: 2,
                fillOpacity: 0.2
            };

            if (mode === 'polygon') {
                drawHandler = new L.Draw.Polygon(map, { shapeOptions: shapeOptions });
            } else {
                drawHandler = new L.Draw.Rectangle(map, { shapeOptions: shapeOptions });
            }
            drawHandler.enable();
            setDrawingState(true);
        }

        function setDrawingState(drawing) {
            isDrawing = drawing;
            var rectBtn = document.getElementById('drawBtn');
            var polyBtn = document.getElementById('drawPolyBtn');
            if (drawing) {
                // Show cancel state on the active button, disable the other
                if (activeDrawMode === 'polygon') {
                    polyBtn.classList.add('drawing');
                    polyBtn.innerHTML = '&#10005; Cancel Drawing';
                    rectBtn.disabled = true;
                } else {
                    rectBtn.classList.add('drawing');
                    rectBtn.innerHTML = '&#10005; Cancel Drawing';
                    polyBtn.disabled = true;
                }
            } else {
                rectBtn.classList.remove('drawing');
                rectBtn.innerHTML = '&#9645; Draw Rectangle';
                rectBtn.disabled = false;
                polyBtn.classList.remove('drawing');
                polyBtn.innerHTML = '&#11040; Draw Polygon';
                polyBtn.disabled = false;
                drawHandler = null;
                activeDrawMode = null;
            }
        }

        // Calculate polygon area in km² using Shoelace formula on projected coordinates
        function calculatePolygonAreaKm2(vertices) {
            var n = vertices.length;
            if (n < 3) return 0;
            var area = 0;
            for (var i = 0; i < n; i++) {
                var j = (i + 1) % n;
                // Convert to approximate km
                var xi = vertices[i].lng * 111.32 * Math.cos(vertices[i].lat * Math.PI / 180);
                var yi = vertices[i].lat * 111.32;
                var xj = vertices[j].lng * 111.32 * Math.cos(vertices[j].lat * Math.PI / 180);
                var yj = vertices[j].lat * 111.32;
                area += xi * yj - xj * yi;
            }
            return Math.abs(area / 2);
        }

        function updateStatus() {
            var statusDiv = document.getElementById('status');
            var loadBtn = document.getElementById('loadBtn');

            if (currentBounds === null) {
                statusDiv.className = 'status-info';
                statusDiv.innerHTML = 'Ready. Draw a rectangle or polygon to select an area.';
                loadBtn.disabled = true;
                return;
            }

            var ne = currentBounds.getNorthEast();
            var sw = currentBounds.getSouthWest();

            var areaText = currentArea < 0.01 ?
                (currentArea * 1000000).toFixed(0) + ' m²' :
                currentArea.toFixed(2) + ' km²';

            var shapeType = currentPolygonVertices ? 'Polygon (' + currentPolygonVertices.length + ' vertices)' : 'Rectangle';

            if (currentArea > MAX_AREA_KM2) {
                statusDiv.className = 'status-error';
                statusDiv.innerHTML = '⚠ Area too large: ' + areaText + ' (max: ' + MAX_AREA_KM2 + ' km²)<br>' +
                    shapeType + ' — Please select a smaller area.<br>' +
                    'Bounds: [' + sw.lat.toFixed(5) + ', ' + sw.lng.toFixed(5) + '] to [' + ne.lat.toFixed(5) + ', ' + ne.lng.toFixed(5) + ']';
                loadBtn.disabled = true;

                // Show warning modal
                showWarningModal(areaText);
            } else {
                statusDiv.className = 'status-info';
                statusDiv.innerHTML = shapeType + ' — Area: ' + areaText + '<br>' +
                    'Bounds: [' + sw.lat.toFixed(5) + ', ' + sw.lng.toFixed(5) + '] to [' + ne.lat.toFixed(5) + ', ' + ne.lng.toFixed(5) + ']';
                loadBtn.disabled = false;
            }
        }

        function clearSelection() {
            drawnItems.clearLayers();
            currentBounds = null;
            currentPolygonVertices = null;
            currentArea = 0;
            updateStatus();
        }

        function showWarningModal(areaText) {
            document.getElementById('modalAreaText').textContent = areaText;
            document.getElementById('warningModal').style.display = 'block';
        }

        function closeWarningModal() {
            document.getElementById('warningModal').style.display = 'none';
        }

        function loadToDesignBuilder() {
            if (currentBounds === null) {
                alert('Please select an area first.');
                return;
            }

            // Check if area exceeds maximum
            if (currentArea > MAX_AREA_KM2) {
                var areaText = currentArea < 0.01 ?
                    (currentArea * 1000000).toFixed(0) + ' m²' :
                    currentArea.toFixed(2) + ' km²';
                showWarningModal(areaText);
                return;
            }

            var ne = currentBounds.getNorthEast();
            var sw = currentBounds.getSouthWest();

            // Create selection object with bounding box and optional polygon vertices
            var selection = {
                south: sw.lat,
                west: sw.lng,
                north: ne.lat,
                east: ne.lng,
                area: currentArea,
                polygon: currentPolygonVertices
            };

            // Send to C# via window.chrome.webview
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(JSON.stringify(selection));
            } else {
                alert('Communication with plugin failed. Please try again.');
            }
        }

        // Search location using Nominatim (OpenStreetMap's geocoding API)
        async function searchLocation() {
            var searchInput = document.getElementById('searchInput');
            var searchBtn = document.getElementById('searchBtn');
            var searchResults = document.getElementById('searchResults');
            var query = searchInput.value.trim();

            if (!query) {
                return;
            }

            // Disable search button during search
            searchBtn.disabled = true;
            searchBtn.textContent = 'Searching...';

            try {
                // Call Nominatim API
                var url = 'https://nominatim.openstreetmap.org/search?format=json&q=' + encodeURIComponent(query) + '&limit=5';

                console.log('Searching for:', query);
                console.log('URL:', url);

                var response = await fetch(url, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });

                console.log('Response status:', response.status);

                if (!response.ok) {
                    throw new Error('Search failed with status: ' + response.status);
                }

                var results = await response.json();
                console.log('Results:', results);

                // Display results
                displaySearchResults(results);
            } catch (error) {
                console.error('Search error:', error);
                searchResults.innerHTML = '<div class="search-no-results">Search failed: ' + error.message + '<br>Please try again.</div>';
                searchResults.style.display = 'block';
            } finally {
                // Re-enable search button
                searchBtn.disabled = false;
                searchBtn.textContent = 'Search';
            }
        }

        function displaySearchResults(results) {
            var searchResults = document.getElementById('searchResults');

            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found. Try a different search term.</div>';
                searchResults.style.display = 'block';
                return;
            }

            // Build results HTML
            var html = '';
            results.forEach(function (result, index) {
                html += '<div class="search-result-item" onclick="selectSearchResult(' + index + ')">';
                html += '<div class="search-result-name">' + escapeHtml(result.display_name.split(',')[0]) + '</div>';
                html += '<div class="search-result-address">' + escapeHtml(result.display_name) + '</div>';
                html += '</div>';
            });

            searchResults.innerHTML = html;
            searchResults.style.display = 'block';

            // Store results for selection
            window.searchResultsData = results;
        }

        function selectSearchResult(index) {
            var result = window.searchResultsData[index];

            // Hide search results
            document.getElementById('searchResults').style.display = 'none';

            // Parse coordinates
            var lat = parseFloat(result.lat);
            var lon = parseFloat(result.lon);

            // Remove previous search marker if exists
            if (searchMarker) {
                map.removeLayer(searchMarker);
            }

            // Add marker at search location
            searchMarker = L.marker([lat, lon]).addTo(map);
            searchMarker.bindPopup('<b>' + escapeHtml(result.display_name.split(',')[0]) + '</b><br>' + escapeHtml(result.display_name)).openPopup();

            // Zoom to location
            var zoom = 15; // Default zoom level
            if (result.boundingbox) {
                // If bounding box is available, fit to bounds
                var bbox = result.boundingbox;
                var bounds = [
                    [parseFloat(bbox[0]), parseFloat(bbox[2])],
                    [parseFloat(bbox[1]), parseFloat(bbox[3])]
                ];
                map.fitBounds(bounds);
            } else {
                // Otherwise, just center and zoom
                map.setView([lat, lon], zoom);
            }

            // Clear search input
            document.getElementById('searchInput').value = '';
        }

        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchLocation();
            }
        }

        function escapeHtml(text) {
            var div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Close search results when clicking outside
        document.addEventListener('click', function (event) {
            var searchResults = document.getElementById('searchResults');
            var searchContainer = document.getElementById('searchContainer');

            if (!searchContainer.contains(event.target) && !searchResults.contains(event.target)) {
                searchResults.style.display = 'none';
            }
        });

        // Initialize map when page loads
        window.onload = initMap;
    </script>
</body>

</html>